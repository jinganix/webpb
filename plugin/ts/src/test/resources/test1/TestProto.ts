// Code generated by Webpb compiler, do not edit.
// https://github.com/jinganix/webpb
// Test.proto

import * as Webpb from "webpb";
import * as Include2Proto from "./Include2Proto";
import * as IncludeProto from "./IncludeProto";

export interface ITest1 {
  test1: string;
  test2: number;
}

export class Test1 implements ITest1, Webpb.WebpbMessage {
  test1!: string;
  test2!: number;
  webpbMeta: () => Webpb.WebpbMeta;

  protected constructor(p?: ITest1) {
    Webpb.assign(p, this, []);
    this.webpbMeta = () => (p && {
      class: "Test1",
      context: "/test",
      method: "GET",
      path: `/test${Webpb.query("?", {
        "a": "123",
        "b": p.test1,
        "c": "321",
        "d": p.test2,
        "e": "456",
      })}`
    }) as Webpb.WebpbMeta;
  }

  static create(p: ITest1): Test1 {
    return new Test1(p);
  }

  static fromAlias(data: Record<string, unknown>): Test1 {
    return Test1.create(data as any);
  }

  toWebpbAlias(): unknown {
    return this;
  }
}

export interface ITest2 extends IAbstractClass {
  test1: string;
  test2: string;
  test3: ITest6;
  test4: Record<number, ITest1>;
}

export class Test2 extends AbstractClass implements ITest2, Webpb.WebpbMessage {
  test1!: string;
  test2!: string;
  test3!: ITest6;
  test4!: Record<number, ITest1>;
  webpbMeta: () => Webpb.WebpbMeta;

  protected constructor(p?: ITest2) {
    super();
    Webpb.assign(p, this, []);
    p?.test3 !== undefined && (this.test3 = Test6.create(p.test3));
    p?.test4 !== undefined && (this.test4 = Webpb.mapValues(p.test4, x => Test1.create(x)));
    this.webpbMeta = () => (p && {
      class: "Test2",
      context: "/test",
      method: "GET",
      path: `/test/${p.test2}${Webpb.query("?", {
        "id": p.test1,
        "data1": Webpb.getter(p, "test3.test1"),
        "data2": Webpb.getter(p, "test3.test2"),
      })}`
    }) as Webpb.WebpbMeta;
  }

  static create(p: ITest2): Test2 {
    return new Test2(p);
  }

  static fromAlias(data: Record<string, unknown>): Test2 {
    return Test2.create(data as any);
  }

  toWebpbAlias(): unknown {
    return this;
  }
}

export interface ITest4 {
  test1: string;
  test2: number;
  test3: string;
  test4: string[];
}

export class Test4 implements ITest4, Webpb.WebpbMessage {
  test1!: string;
  test2!: number;
  test3!: string;
  test4!: string[];
  webpbMeta: () => Webpb.WebpbMeta;

  protected constructor(p?: ITest4) {
    Webpb.assign(p, this, []);
    this.webpbMeta = () => (p && {
      class: "Test4",
      context: "",
      method: "",
      path: "",
    }) as Webpb.WebpbMeta;
  }

  static create(p: ITest4): Test4 {
    return new Test4(p);
  }

  static fromAlias(data: Record<string, unknown>): Test4 {
    const p = Webpb.toAlias(data, {
      "aliasTest1": "test1",
      "aliasTest2": "test2",
    });
    return Test4.create(p);
  }

  toWebpbAlias(): unknown {
    return Webpb.toAlias(this, {
      "test1": "aliasTest1",
      "test2": "aliasTest2",
    });
  }
}

export interface ITest6 {
  test1: string;
  test2?: number;
}

export class Test6 implements ITest6, Webpb.WebpbMessage {
  test1!: string;
  test2?: number;
  webpbMeta: () => Webpb.WebpbMeta;

  protected constructor(p?: ITest6) {
    Webpb.assign(p, this, []);
    this.webpbMeta = () => (p && {
      class: "Test6",
      context: "",
      method: "",
      path: "",
    }) as Webpb.WebpbMeta;
  }

  static create(p: ITest6): Test6 {
    return new Test6(p);
  }

  static fromAlias(data: Record<string, unknown>): Test6 {
    return Test6.create(data as any);
  }

  toWebpbAlias(): unknown {
    return this;
  }
}

export interface ITest {
  test1: number;
  test2: IncludeProto.IMessage;
  test3: IncludeProto.Enum;
  test4?: ITest4;
  test5: Record<string, number>;
  test6: Record<number, IncludeProto.IMessage>;
  test7: unknown;
  test8: Test.INestedTest;
  test9?: number;
  test10: string;
  test11: IncludeProto.IMessage[];
  test12: IncludeProto.Message.INested;
  test13: Include2Proto.IMessage[];
  test14: Include2Proto.Message.INested;
  test15: string;
  test16: Uint8Array;
  test17: Test.ITest17;
  test18: number;
  test19: string;
}

export class Test implements ITest, Webpb.WebpbMessage {
  test1!: number;
  test2!: IncludeProto.IMessage;
  test3!: IncludeProto.Enum;
  test4?: ITest4;
  test5!: Record<string, number>;
  test6!: Record<number, IncludeProto.IMessage>;
  test7!: unknown;
  test8!: Test.INestedTest;
  test9?: number;
  test10!: string;
  test11!: IncludeProto.IMessage[];
  test12!: IncludeProto.Message.INested;
  test13!: Include2Proto.IMessage[];
  test14!: Include2Proto.Message.INested;
  test15!: string;
  test16!: Uint8Array;
  test17!: Test.ITest17;
  test18: number = 123;
  test19: string = "test19";
  webpbMeta: () => Webpb.WebpbMeta;

  protected constructor(p?: ITest) {
    Webpb.assign(p, this, ["test1", "test9"]);
    p?.test2 !== undefined && (this.test2 = IncludeProto.Message.create(p.test2));
    p?.test4 !== undefined && (this.test4 = Test4.create(p.test4));
    p?.test6 !== undefined && (this.test6 = Webpb.mapValues(p.test6, x => IncludeProto.Message.create(x)));
    p?.test8 !== undefined && (this.test8 = Test.NestedTest.create(p.test8));
    p?.test11 !== undefined && (this.test11 = p.test11.map(x => IncludeProto.Message.create(x)));
    p?.test12 !== undefined && (this.test12 = IncludeProto.Message.Nested.create(p.test12));
    p?.test13 !== undefined && (this.test13 = p.test13.map(x => Include2Proto.Message.create(x)));
    p?.test14 !== undefined && (this.test14 = Include2Proto.Message.Nested.create(p.test14));
    p?.test17 !== undefined && (this.test17 = Test.Test17.create(p.test17));
    this.webpbMeta = () => (p && {
      class: "Test",
      context: "/test",
      method: "GET",
      path: `/test/${p.test1}`
    }) as Webpb.WebpbMeta;
  }

  static create(p: ITest): Test {
    return new Test(p);
  }

  static fromAlias(data: Record<string, unknown>): Test {
    const p = Webpb.toAlias(data, {});
    p.test11 && (p.test11 = p.test11.map(x => IncludeProto.Message.fromAlias(x)));
    p.test12 && (p.test12 = IncludeProto.Message.Nested.fromAlias(p.test12));
    p.test13 && (p.test13 = p.test13.map(x => Include2Proto.Message.fromAlias(x)));
    p.test14 && (p.test14 = Include2Proto.Message.Nested.fromAlias(p.test14));
    p.test17 && (p.test17 = Test.Test17.fromAlias(p.test17));
    p.test2 && (p.test2 = IncludeProto.Message.fromAlias(p.test2));
    p.test4 && (p.test4 = Test4.fromAlias(p.test4));
    p.test6 && (p.test6 = Webpb.mapValues(p.test6, x => IncludeProto.Message.fromAlias(x)));
    p.test8 && (p.test8 = Test.NestedTest.fromAlias(p.test8));
    return Test.create(p);
  }

  toWebpbAlias(): unknown {
    return Webpb.toAlias(this, {});
  }
}

export namespace Test {
  export interface INestedTest {
    test1: number;
  }

  export class NestedTest implements INestedTest, Webpb.WebpbMessage {
    test1!: number;
    webpbMeta: () => Webpb.WebpbMeta;

    protected constructor(p?: INestedTest) {
      Webpb.assign(p, this, []);
      this.webpbMeta = () => (p && {
        class: "NestedTest",
        context: "/test",
        method: "GET",
        path: `/test/nested/${p.test1}`
      }) as Webpb.WebpbMeta;
    }

    static create(p: INestedTest): NestedTest {
      return new NestedTest(p);
    }

    static fromAlias(data: Record<string, unknown>): NestedTest {
      return NestedTest.create(data as any);
    }

    toWebpbAlias(): unknown {
      return this;
    }
  }

  export interface ITest17 {
    test: string;
  }

  export class Test17 implements ITest17, Webpb.WebpbMessage {
    test!: string;
    webpbMeta: () => Webpb.WebpbMeta;

    protected constructor(p?: ITest17) {
      Webpb.assign(p, this, []);
      this.webpbMeta = () => (p && {
        class: "Test17",
        context: "",
        method: "",
        path: "",
      }) as Webpb.WebpbMeta;
    }

    static create(p: ITest17): Test17 {
      return new Test17(p);
    }

    static fromAlias(data: Record<string, unknown>): Test17 {
      return Test17.create(data as any);
    }

    toWebpbAlias(): unknown {
      return this;
    }
  }
}

export enum Test3 {
  test3_1 = "test3_1",
  test3_2 = "test3_2",
  test3_3 = "test3_3",
}

export const enum ConstTest3 {
  test3_1 = "test3_1",
  test3_2 = "test3_2",
  test3_3 = "test3_3",
}

export enum Test5 {
  test5_1 = "text1",
  test5_2 = "text2",
  test5_3 = "test5_3",
}

export const enum ConstTest5 {
  test5_1 = "text1",
  test5_2 = "text2",
  test5_3 = "test5_3",
}
