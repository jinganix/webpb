// Code generated by Webpb compiler, do not edit.
// https://github.com/jinganix/webpb
// Test.proto

import * as Webpb from "webpb";
import * as Include2Proto from "./Include2Proto";
import * as IncludeProto from "./IncludeProto";

export enum Test3 {
  test3_1 = "test3_1",
  test3_2 = "test3_2",
  test3_3 = "test3_3",
}

export const Test3Values = [
  Test3.test3_1,
  Test3.test3_2,
  Test3.test3_3,
];

export const enum ConstTest3 {
  test3_1 = "test3_1",
  test3_2 = "test3_2",
  test3_3 = "test3_3",
}

export const ConstTest3Values = [
  ConstTest3.test3_1,
  ConstTest3.test3_2,
  ConstTest3.test3_3,
];

export enum Test5 {
  test5_1 = "text1",
  test5_2 = "text2",
  test5_3 = "test5_3",
}

export const Test5Values = [
  Test5.test5_1,
  Test5.test5_2,
  Test5.test5_3,
];

export const enum ConstTest5 {
  test5_1 = "text1",
  test5_2 = "text2",
  test5_3 = "test5_3",
}

export const ConstTest5Values = [
  ConstTest5.test5_1,
  ConstTest5.test5_2,
  ConstTest5.test5_3,
];

export interface ITest1 {
  test1: string;
  test2: number;
}

export class Test1 implements ITest1, Webpb.WebpbMessage {
  test1!: string;
  test2!: number;
  webpbMeta: () => Webpb.WebpbMeta;

  static CLASS = "Test1";
  static CONTEXT = "/test";
  static METHOD = "GET";
  static PATH = "/test?a=123&b={test1}&c=321&d={test2}&e=456";

  protected constructor(p?: ITest1) {
    Webpb.assign(p, this, []);
    this.webpbMeta = () =>
      ({
        class: "Test1",
        context: "/test",
        method: "GET",
        path: `/test${Webpb.query("?", {
          "a": "123",
          "b": p?.test1,
          "c": "321",
          "d": p?.test2,
          "e": "456",
        })}`,
      } as Webpb.WebpbMeta);
  }

  static create(p?: ITest1): Test1 {
    return new Test1(p);
  }

  static fromAlias(data?: unknown): Test1 {
    return Test1.create(data as ITest1);
  }

  toWebpbAlias(): unknown {
    return this;
  }
}

export interface ITest2 extends IAbstractClass {
  test1: string;
  test2: string;
  test3: ITest6;
  test4: Record<number, ITest1>;
}

export class Test2 extends AbstractClass implements ITest2, Webpb.WebpbMessage {
  test1!: string;
  test2!: string;
  test3!: ITest6;
  test4!: Record<number, ITest1>;
  webpbMeta: () => Webpb.WebpbMeta;

  static CLASS = "Test2";
  static CONTEXT = "/test";
  static METHOD = "GET";
  static PATH = "/test/{test2}?id={test1}&data1={test3.test1}&data2={test3.test2}";

  protected constructor(p?: ITest2) {
    super();
    Webpb.assign(p, this, []);
    p?.test3 && (this.test3 = Test6.create(p.test3));
    p?.test4 && (this.test4 = Webpb.mapValues(p.test4, (x) => Test1.create(x)));
    this.webpbMeta = () =>
      ({
        class: "Test2",
        context: "/test",
        method: "GET",
        path: `/test/${p?.test2}${Webpb.query("?", {
          "id": p?.test1,
          "data1": Webpb.getter(p, "test3.test1"),
          "data2": Webpb.getter(p, "test3.test2"),
        })}`,
      } as Webpb.WebpbMeta);
  }

  static create(p?: ITest2): Test2 {
    return new Test2(p);
  }

  static fromAlias(data?: unknown): Test2 {
    const p = data as Record<string, unknown>;
    p?.test3 && (p.test3 = Test6.fromAlias(p.test3));
    p?.test4 && (p.test4 = Webpb.mapValues(p.test4, (x) => Test1.fromAlias(x)));
    return Object.assign(new Test2(), p);
  }

  toWebpbAlias(): unknown {
    return Webpb.toAlias(this, {});
  }
}

export interface ITest4 {
  test1: string;
  test2: number;
  test3: string;
  test4: string[];
}

export class Test4 implements ITest4, Webpb.WebpbMessage {
  test1!: string;
  test2!: number;
  test3!: string;
  test4!: string[];
  webpbMeta: () => Webpb.WebpbMeta;

  static CLASS = "Test4";
  static CONTEXT = "";
  static METHOD = "";
  static PATH = "";

  protected constructor(p?: ITest4) {
    Webpb.assign(p, this, []);
    this.webpbMeta = () =>
      ({
        class: "Test4",
        context: "",
        method: "",
        path: "",
      } as Webpb.WebpbMeta);
  }

  static create(p?: ITest4): Test4 {
    return new Test4(p);
  }

  static fromAlias(data?: unknown): Test4 {
    const p = Webpb.toAlias(data, {
      "aliasTest1": "test1",
      "aliasTest2": "test2",
    }) as Record<string, unknown>;
    return Object.assign(new Test4(), p);
  }

  toWebpbAlias(): unknown {
    return Webpb.toAlias(this, {
      "test1": "aliasTest1",
      "test2": "aliasTest2",
    });
  }
}

export interface ITest6 {
  test1: string;
  test2?: number;
}

export class Test6 implements ITest6, Webpb.WebpbMessage {
  test1!: string;
  test2?: number;
  webpbMeta: () => Webpb.WebpbMeta;

  static CLASS = "Test6";
  static CONTEXT = "";
  static METHOD = "";
  static PATH = "";

  protected constructor(p?: ITest6) {
    Webpb.assign(p, this, []);
    this.webpbMeta = () =>
      ({
        class: "Test6",
        context: "",
        method: "",
        path: "",
      } as Webpb.WebpbMeta);
  }

  static create(p?: ITest6): Test6 {
    return new Test6(p);
  }

  static fromAlias(data?: unknown): Test6 {
    return Test6.create(data as ITest6);
  }

  toWebpbAlias(): unknown {
    return this;
  }
}

export interface ITest {
  test1: number;
  test2: IncludeProto.IMessage;
  test3: IncludeProto.Enum;
  test4?: ITest4;
  test5: Record<string, number>;
  test6: Record<number, IncludeProto.IMessage>;
  test7: unknown;
  test8: Test.INestedTest;
  test9?: number;
  test10: string;
  test11: IncludeProto.IMessage[];
  test12: IncludeProto.Message.INested;
  test13: Include2Proto.IMessage[];
  test14: Include2Proto.Message.INested;
  test15: string;
  test16: Uint8Array;
  test17: Test.ITest17;
  test18: number;
  test19: string;
}

export class Test implements ITest, Webpb.WebpbMessage {
  test1!: number;
  test2!: IncludeProto.IMessage;
  test3!: IncludeProto.Enum;
  test4?: ITest4;
  test5!: Record<string, number>;
  test6!: Record<number, IncludeProto.IMessage>;
  test7!: unknown;
  test8!: Test.INestedTest;
  test9?: number;
  test10!: string;
  test11!: IncludeProto.IMessage[];
  test12!: IncludeProto.Message.INested;
  test13!: Include2Proto.IMessage[];
  test14!: Include2Proto.Message.INested;
  test15!: string;
  test16!: Uint8Array;
  test17!: Test.ITest17;
  test18: number = 123;
  test19: string = "test19";
  webpbMeta: () => Webpb.WebpbMeta;

  static CLASS = "Test";
  static CONTEXT = "/test";
  static METHOD = "GET";
  static PATH = "/test/{test1}";

  protected constructor(p?: ITest) {
    Webpb.assign(p, this, ["test1", "test9"]);
    p?.test2 && (this.test2 = IncludeProto.Message.create(p.test2));
    p?.test4 && (this.test4 = Test4.create(p.test4));
    p?.test6 && (this.test6 = Webpb.mapValues(p.test6, (x) => IncludeProto.Message.create(x)));
    p?.test8 && (this.test8 = Test.NestedTest.create(p.test8));
    p?.test11 && (this.test11 = p.test11.map((x) => IncludeProto.Message.create(x)));
    p?.test12 && (this.test12 = IncludeProto.Message.Nested.create(p.test12));
    p?.test13 && (this.test13 = p.test13.map((x) => Include2Proto.Message.create(x)));
    p?.test14 && (this.test14 = Include2Proto.Message.Nested.create(p.test14));
    p?.test17 && (this.test17 = Test.Test17.create(p.test17));
    this.webpbMeta = () =>
      ({
        class: "Test",
        context: "/test",
        method: "GET",
        path: `/test/${p?.test1}`,
      } as Webpb.WebpbMeta);
  }

  static create(p?: ITest): Test {
    return new Test(p);
  }

  static fromAlias(data?: unknown): Test {
    const p = data as Record<string, unknown>;
    p?.test11 && (p.test11 = (p.test11 as Webpb.WebpbMessage[]).map((x) => IncludeProto.Message.fromAlias(x)));
    p?.test12 && (p.test12 = IncludeProto.Message.Nested.fromAlias(p.test12));
    p?.test13 && (p.test13 = (p.test13 as Webpb.WebpbMessage[]).map((x) => Include2Proto.Message.fromAlias(x)));
    p?.test14 && (p.test14 = Include2Proto.Message.Nested.fromAlias(p.test14));
    p?.test17 && (p.test17 = Test.Test17.fromAlias(p.test17));
    p?.test2 && (p.test2 = IncludeProto.Message.fromAlias(p.test2));
    p?.test4 && (p.test4 = Test4.fromAlias(p.test4));
    p?.test6 && (p.test6 = Webpb.mapValues(p.test6, (x) => IncludeProto.Message.fromAlias(x)));
    p?.test8 && (p.test8 = Test.NestedTest.fromAlias(p.test8));
    return Object.assign(new Test(), p);
  }

  toWebpbAlias(): unknown {
    return Webpb.toAlias(this, {});
  }
}

export namespace Test {
  export interface INestedTest {
    test1: number;
  }

  export class NestedTest implements INestedTest, Webpb.WebpbMessage {
    test1!: number;
    webpbMeta: () => Webpb.WebpbMeta;

    static CLASS = "NestedTest";
    static CONTEXT = "/test";
    static METHOD = "GET";
    static PATH = "/test/nested/{test1}";

    protected constructor(p?: INestedTest) {
      Webpb.assign(p, this, []);
      this.webpbMeta = () =>
        ({
          class: "NestedTest",
          context: "/test",
          method: "GET",
          path: `/test/nested/${p?.test1}`,
        } as Webpb.WebpbMeta);
    }

    static create(p?: INestedTest): NestedTest {
      return new NestedTest(p);
    }

    static fromAlias(data?: unknown): NestedTest {
      return NestedTest.create(data as INestedTest);
    }

    toWebpbAlias(): unknown {
      return this;
    }
  }

  export interface ITest17 {
    test: string;
  }

  export class Test17 implements ITest17, Webpb.WebpbMessage {
    test!: string;
    webpbMeta: () => Webpb.WebpbMeta;

    static CLASS = "Test17";
    static CONTEXT = "";
    static METHOD = "";
    static PATH = "";

    protected constructor(p?: ITest17) {
      Webpb.assign(p, this, []);
      this.webpbMeta = () =>
        ({
          class: "Test17",
          context: "",
          method: "",
          path: "",
        } as Webpb.WebpbMeta);
    }

    static create(p?: ITest17): Test17 {
      return new Test17(p);
    }

    static fromAlias(data?: unknown): Test17 {
      return Test17.create(data as ITest17);
    }

    toWebpbAlias(): unknown {
      return this;
    }
  }
}
